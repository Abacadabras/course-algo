Анализ числовых последовательностей С++.
#################################

:date: 2018-09-30 09:00
:summary: Анализ числовых последовательностей С++.

.. default-role:: code

Получение параметров командной строки через аргументы main().
========
Программа должна иметь глобальную функцию main — точку старта программы. 


.. code-block:: c

	#include <iostream>
  int  main(int argc, char* argv[]) // параметры функции main()
	



Эта строка — заголовок главной функции main(), в скобочках объявлены параметры argс и argv. 
При запуске программы через командную строку возможна передача информации через аргументы, для этого и существуют
параметры argc и argv[] . Параметр argc имеет тип данных int, и содержит количество параметров, 
передаваемых в функцию main. Причем argc всегда не меньше 1, даже когда мы не передаем никакой информации, 
так как argv[0] — это команда, с помощью которой вызывается программа, argv[1] — это первый аргумент командной 
строки и так далее до argv[argc], который всегда имеет значение NULL. 

Через командную строку  можно передать только данные строкового типа.
Разработаем программу, которую будем запускать через командную строку, и передавать ей некоторую информацию.

.. code-block:: c

   #include <iostream>
   using namespace std;
   int main(int argc, char* argv[])
   {
       if (argc > 1)// если передаем аргументы, то argc будет больше 1
       
       {
             for (int i = 0; i < argc; i++) { cout << "Argument " << i << " : " << argv[i] << endl; } 
      }
      
        else
               {
       cout << "Not arguments" << endl;
               }
               
       return 0;
     }



Для получения числовых данных из входных параметров, можно использовать функции atoi и atof библиотеки <cstdlib>:
int atoi(const char *str);  float atoi(const char *str);  - преобразуют текстовые строки str в числа.


Упражнение 1.
Создайте программу, которая будет обрабатывать параметры функции main:

1)      Если параметров нет, то выводит "No arguments";

2)      Если параметр один, то выводит его;

3)      Если параметров 2 , то выводит среднее арифметическое (числа);

4)      Если параметров > 3, то выводит максимальный из них.

Запустите эту программу из терминала для каждого из 4 случаев.



Следующая программа показывает, как передавать аргументы командной строки:


.. code-block:: c

   #include <iostream> 
   using namespace std; 
   int main( int argc,      // Количество элементов в массиве argv
          char *argv[],   // Массив аргументов командной строки 
          char *envp[] )  // Массив переменных окружнения 
   { 
    int count; 
      // Показать аргументы командной строки
    cout << "\nCommand-line arguments:\n"; 
    for( i = 0; i < argc; i++ ) 
         cout << "  argv[" << i << "]   " 
                << argv[count] << "\n"; 
    } 


char *envp[] – это массив указателей на значения переменных окружения. С помощью него можно их вывести. Запустите код:

.. code-block:: c
   
   #include <iostream> 
   using namespace std;
   main(int argc, char** argv, char** env)
    {      int i = 0;
    while(env[i] != 0)
    {
       cout << "\n" << env[i++];
    }
    return 0;
    }


Функция main() возвращает целое значение, которое является кодом возврата (return code). По умолчанию она возвращает 0 при правильной работе программы (в противном случае возвращается код ошибки), но лучше явно писать return 0 в программе, так как без этой строчки программа не всегда может корректно работать.




Чтение из файла через ifstream и запись в файл через ofstream.
========

Существуют два основных типа файлов: текстовые и двоичные. Текстовыми называются файлы, состоящие из любых печатных символов. Они организуются по строкам, каждая из которых заканчивается символом «конца строки» ("\\n").


Конец самого файла обозначается индикатором конца файла EOF. Для указания терминалу в UNIX и Linux «EOF» следует воспользоваться комбинацией клавиш Ctrl+D. В Windows — Ctrl+Z. При записи информации в текстовый файл, просмотреть который можно с помощью любого текстового редактора, все данные преобразуются к символьному типу. В двоичных файлах информация считывается и записывается в виде блоков определенного размера, в которых могут храниться данные любого вида и структуры.


Для работы с файлами используются специальные типы данных, называемые потоками. Поток ifstream служит для работы с файлами в режиме чтения, а ofstream в режиме записи. Для работы с файлами в режиме как записи, так и чтения служит поток fstream.  В программах на C++ при работе с текстовыми файлами необходимо подключать библиотеки iostream и fstream.
Для того, чтобы записывать данные в текстовый файл, необходимо:


1.     описать переменную типа ofstream.


2.     открыть файл с помощью функции open.


3.     вывести информацию в файл.


4.     обязательно закрыть файл.


Для считывания данных из текстового файла, необходимо:


1.     описать переменную типа ifstream.


2.     открыть файл с помощью функции open.


3.     считать информацию из файла, при считывании каждой порции данных необходимо проверять, достигнут ли конец файла.


4.     закрыть файл.


ios::out является режимом по умолчанию для потока ofstream:

ofstream F;  F.open(«/home/student/noobs.txt»);

или: 

ofstream F («/home/student/noobs.txt», ios::out);

fstream предоставляет функционал для считывания данных из файла и для записи в файл. В целом он очень похож на iostream, который работает с консолью. Наиболее часто используются:

1.     Операторы перенаправления ввода\\вывода – << и >>

2.     Методы записи и чтения строк getline() и get() c put()

3.     Потоковая запись и чтение методами write() и read()

4.     Методы открытия\\создания и закрытия файлов open() и close()

5.     Методы проверки открыт ли файл is_open() и достигнут ли конец файла eof()

6.     Настройка форматированного вывода для >> с помощью width() и precision()

7.     Операции позиционирования tellg(), tellp() и seekg(), seekp()


Это не все возможности, которые предоставляет библиотека fstream. Рассматривать все сейчас мы не будем, поскольку их круг применения достаточно узок.
Так же как и в iostream считывание можно организовать оператором >>, который указывает, в какую переменную будет произведено считывание. Этот оператор достаточно удобен, если стоит задача разделить файл на слова или числа:


.. code-block:: c
   
   #include <fstream>
   using namespace std;

   int main(int argc, char* argv[])
   {
        ofstream fout("hello.txt");
        fout << "Hello world";
        fout.close();
	ifstream fin("hello.txt");
	for(fin >> s; !fin.eof(); fin >> s) cout << s << endl;
	fin.close();
        return 0;
   }


Метод read(). Используется для чтения из файла.

Метод close(). Открытые файлы следует закрывать:  file.close().

Метод eof(). Проверяет, не достигнут ли конец файла. Т.е. можно ли из него продолжать чтение.

Метод write(). Используется для записи в файл.

Метод is.open(). Метод is_open() вернет 1, если файл найден и успешно открыт. Иначе вернет 0.

Метод seekg(). Функция seekg() используется с потоками ввода. Она смещает указатель "get" для текущего потока на offset байтов, или располагает указатель "get" в позицию position.

seekg( pos_type position );   seekg( off_type offset, ios::seekdir origin) 

Например: infile.seekg (0); – перемещает указатель в начало файла.

Метод tellg(). Функция tellg() используется с потоками ввода. Она возвращает текущую позицию указателя ввода "get" в потоке – этот указатель обычно называют курсором. При обычном открытии файла курсор на позиции 0 (начало файла).


Примеры использования методов:

.. code-block:: c
   
   ofstream ofs("test.txt"); //создать
   ofs.close(); 
   std::remove("test.txt"); //удалить


.. code-block:: c

   #include <iostream>
   #include <fstream> // std::ifstream, std::ofstream

   using namespace std;

   int main () {
   
   // создаём файл для считывания из него
   
   ofstream out0file ("test.txt",ofstream::binary);
   out0file.write ("hello", 5);
   out0file.close();

   ifstream infile ("test.txt",ifstream::binary);
   ofstream outfile ("new.txt",ofstream::binary);

   // определяем размер файла входных данных

  infile.seekg (0, infile.end);
  long size = infile.tellg();
  infile.seekg (0);

  // создаём массив из символов нужного размера
  char buffer [size];

  // читаем файл
  infile.read (buffer,size);

  // записываем в другой файл
  outfile.write (buffer,size);

  //закрываем файлы
  outfile.close();
  infile.close();
  return 0;
   }


Второй пример нежелательно использовать для файлов серьёзного размера, так как может привести к нехватке оперативной памяти.

