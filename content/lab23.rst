Функциональное программирование. Клеточные Автоматы
###################################################

:date: 2019-03-17
:status: draft

.. default-role:: code
.. contents:: Содержание


Функциональное программирование
===============================

Функциональное программирование — раздел дискретной математики и парадигма программирования, в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних (в отличие от функций как подпрограмм в процедурном программировании) и предполагает обходиться вычислением результатов функций от исходных данных и результатов других функций, и не предполагает явного хранения состояния программы. Соответственно, не предполагает оно и изменяемость этого состояния (в отличие от императивного, где одной из базовых концепций является переменная, хранящая своё значение и позволяющая менять его по мере выполнения алгоритма).

Как правило, когда рассматривают функциональное программирование в Python, то подразумевают следующие функции: `lambda`, `map`, `filter`, `reduce`, `zip`.

lambda
------

`lambda` функция в Python это способ создать анонимную функцию, то есть функцию без имени. Такие функции можно назвать одноразовыми, они используются только при создании. Как правило, `lambda` функции используются в комбинации с функциями `filter`, `map`, `reduce`.

Синтаксис `lambda` выражения в Python

.. code-block:: python

   lambda arguments: expression

В качестве  `arguments` передается список аргументов, разделенных запятой, после чего над переданными аргументами выполняется `expression`. Если присвоить `lambda`-функцию переменной, то получим поведение как в обычной функции:

.. code-block:: python

   sum = lambda x,y: x + y
   print (sum(4, 5))
   
   9


Преимущества использования `lambda`-выражений особенно проявляются в связке с другими функциями.


map
---

В Python функция `map` принимает два аргумента: функцию и аргумент составного типа данных, например, список. Функция `map` применяет к каждому элементу списка переданную функцию. Например, чтобы превратить список чисел, представленных в виде строк в список чисел, можно воспользоваться `map`:

.. code-block:: python

   # Преобразование с помощью цикла, без использования map: 
   str_list = ['1', '2', '3', '4', '5', '6', '7']
   int_list = []
   
   for item in str_list:
       int_list.append(int(item))
   
   # Преобразование с помощью цикла, с использованием map: 
   new_list_map = list(map(int, str_list))
   
   print (new_list)
   print (new_list_map)
   
   
   [1, 2, 3, 4, 5, 6, 7]
   [1, 2, 3, 4, 5, 6, 7]


Использование функции `map` занимает меньше строк кода, делает его более читабельным и более быстрым. Функция `map` также работает и с функциями созданными пользователем:

.. code-block:: python

   def cels_to_fahr(cels):
     return 32 + cels * 1.8
   
   cels_temps = [0, 4, 20, 36, 100]
   fahr_temps = list(map(cels_to_fahr, cels_temps))
   print (fahr_temps)
   

   [32.0, 39.2, 68.0, 96.8, 212.0]


Это преобразование можно осуществить используя `lambda`-выражение:

.. code-block:: python

   cels_temps = [0, 4, 20, 36, 100]
   fahr_temps = list(map(lambda x: 32 + x * 1.8, cels_temps))
   print (fahr_temps)
   

   [32.0, 39.2, 68.0, 96.8, 212.0]


Функция `map` может быть так же применена для нескольких списков, в таком случае функция-аргумент должна принимать количество аргументов, соответствующее количеству списков:

.. code-block:: python

   lx = [1, 2, 3]
   ly = [4, 5, 6]
   
   res_list = list(map(lambda x,y: x + y, lx, ly))
   print (res_list)
   

   [5, 7, 9]

Если же количество элементов в списках совпадать не будет, то выполнение закончится на минимальном списке:

.. code-block:: python

   lx = [2,3]
   ly = [4,5,6]
   
   res_list = list(map(lambda x,y: x + y, lx, ly))
   print (res_list)
   
   
   [6, 8]


filter
------

Функция filter предлагает простой вариант фильтрации элементов последовательности. Принимает в качестве аргументов функцию и последовательность, которую необходимо отфильтровать:

.. code-block:: python

   nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
   even_nums =  list(filter(lambda x: x%2 == 0, nums))
   print (even_nums)
   
   
   [2, 4, 6, 8, 10]


Функция, передаваемая в `filter` должна возвращать значение `True` / `False`, чтобы элементы корректно отфильтровались.

reduce
------

Функция `reduce` принимает 2 аргумента: функцию и последовательность. Функция `reduce` последовательно применяет функцию-аргумент к элементам списка, возвращает единичное значение. В Python 2.x функция reduce доступна как встроенная, в то время, как в Python 3 она была перемещена в модуль `functools`.

Вычисление суммы всех элементов списка при помощи `reduce`:

.. code-block:: python

   from functools import reduce
   
   items = [1,2,3,4,5]
   sum_all = reduce(lambda x,y: x + y, items)
   
   print (sum_all)
   

   15


Вычисление наибольшего элемента в списке при помощи reduce:

.. code-block:: python

   from functools import reduce
   
   items = [1, 24, 17, 14, 9, 32, 2]
   all_max = reduce(lambda a,b: a if (a > b) else b, items)
   
   print (all_max)
   

   32


zip
---

Функция `zip` объединяет в кортежи элементы из последовательностей переданных в качестве аргументов.

.. code-block:: python

   a = [1,2,3]
   b = "xyz"
   c = (False, True)
   
   res = list(zip(a, b, c))
   print (res)
   
   
   [(1, 'x', False), (2, 'y', True)]


Функция `zip` прекращает выполнение, как только достигнут конец самого короткого списка.


Клеточный автомат
=================

`Клеточный автомат`__ — это математическая модель, описывающая эволюционирующую во времени систему, состояние которой в
каждый момент времени определяется её состоянием в предыдущий момент. Клеточный автомат состоит из набора клеток, для
каждой из которых задана окрестность, т.е. набор соседних клеток. Для всего автомата в целом задаются правила изменения
состояния клетки в зависимости от состояния клеток, находящихся в её окрестности.

.. __: https://ru.wikipedia.org/wiki/%D0%9A%D0%BB%D0%B5%D1%82%D0%BE%D1%87%D0%BD%D1%8B%D0%B9_%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82

Одномерный клеточный автомат
----------------------------

Рассмотрим простейший пример одномерного клеточного автомата. Под одномерным клеточным автоматом в данном случае
понимается автомат, состоящий из клеток, выстроенных в линию. Т.е. в данном случае у каждой клетки есть ровно два соседа:
один слева и один справа.

Пусть поведение клеточного автомата подчиняется следующим правилам:

#. Клетка находится в одном из двух состояний: 1 или 0.
#. Состояние в следующий момент времени вычисляется следующим образом: `_A[i] = (A[i-1] + A[i+1]) % 2`. Т.е. клетка
   находится в состоянии 1, если в предыдущий момент в этом состянии находилась ровно одна соседняя клетка.

Пример программы, реализующей описанный выше клеточный автомат:

.. code-block:: python

   N = 35

   def cell_calculate(left, current, right):
       return left^right

   def calculate_field(field):
       """field -- список из N ноликов или единичек"""
       new_field = [0]*N
       for i in range(1, N-1):
           new_field[i] = cell_calculate(field[i-1], field[i], field[i+1])
       field[:] = new_field

   def generate_field():
       field = [0]*N
       x = N//2
       field[x] = 1
       return field

   def print_field(field):
       for cell in field:
           print('★' if cell else ' ' , end = '')
       print()

   def modelling():
       """ цикл моделирования клеточного автомата """
       field = generate_field()
       print_field(field)
       for t in range(15):
           calculate_field(field)
           print_field(field)

   if __name__ == '__main__':
       modelling()

Вывод программы:

.. code-block:: text

                 ★                 
                ★ ★                
               ★   ★               
              ★ ★ ★ ★              
             ★       ★             
            ★ ★     ★ ★            
           ★   ★   ★   ★           
          ★ ★ ★ ★ ★ ★ ★ ★          
         ★               ★         
        ★ ★             ★ ★        
       ★   ★           ★   ★       
      ★ ★ ★ ★         ★ ★ ★ ★      
     ★       ★       ★       ★     
    ★ ★     ★ ★     ★ ★     ★ ★    
   ★   ★   ★   ★   ★   ★   ★   ★   
  ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ 


Нетрудно заметить, что результат работы такого клеточного автомата внешне выглядит как дискретный аналог
`треугольника Серпинского`__.

.. __: https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B5%D1%83%D0%B3%D0%BE%D0%BB%D1%8C%D0%BD%D0%B8%D0%BA_%D0%A1%D0%B5%D1%80%D0%BF%D0%B8%D0%BD%D1%81%D0%BA%D0%BE%D0%B3%D0%BE

Код Вольфрама
----------------------------

Если клетка автомата может находится только в двух состояниях, такой автомат называется бинарным. Одномерный бинарный клеточный автомат принято называть простейшим(элементарным), если состояние клетки в любой момент времени зависит только от её собственного состояния и состояния смежных клеток в предыдущий момент времени(окрестности радиуса 1).

Элементарных клеточных автоматов существует всего 256, так как состояний для трёх соседних клеток может быть 2**3, и для каждого состояния может быть два варианта задать новое значение центральной клетки.
Стивен Вольфрам предложил нумеровать эти автоматы числами от 0 до 255, это именование и называется `Код Вольфрама`__.

.. __: https://en.wikipedia.org/wiki/Wolfram_code

Способ нумерования: запишем конфигурации окрестности в виде двоичного числа и отсортируем конфигурации по убыванию. Тогда сам клеточный автомат можо представить как упорядоченный набор результирующих значений для каждой конфигурации, то есть тоже число в двоичной системе счисления, это и будет номер этого клеточного автомата. (Автомат из примера будет это номер 18)

Например для номера 110, в зависимости от состояний соседа слева, самой клетки и соседа справа (первая строка таблицы) на следующем шаге клетка примет одно из состояний, указанных во второй строке.

+-----+-----+-----+-----+-----+-----+-----+-----+
| 111 | 110 | 101 | 100 | 011 | 010 | 001 | 000 |
+=====+=====+=====+=====+=====+=====+=====+=====+
|  0  |  1  |  1  |  0  |  1  |  1  |  1  |  0  |
+-----+-----+-----+-----+-----+-----+-----+-----+

Упражнение №1
+++++++++++++

Напишите программу, реализующую элементарный коннечный автомат по его коду Вольфрама переданному на ввод. Программа должна считывать начальное состояние клеточной ленты из файла.

Указание: Чтобы вычислять значения клеток на концах нужно замкнуть автомат в кольцо - сделать крайнюю левую клетку правым соседом крайней правой и наоборот.

Игра «Жизнь» Джона Конвея
-------------------------

`Игра «Жизнь»`__ — это двумерный клеточный автомат, предложенный математиком Джоном Конвеем. Поведение этого клеточного
автомата подчиняется следующим правилам:

#. Автомат работает на плоскости, разделённой на одинаковые квадратные клетки.
#. Каждая клетка может находиться в двух состояниях: живая или мёртвая.
#. В начальный момент времени задано первое поколение — расположение живых клеток на плоскости.
#. Каждое следующее поколение рассчитывается исходя из состояния прошлого поколения по следующим правилам:

   * в мёртвой клетке зарождается жизнь, если у этой клетки ровно три живых соседних клетки;
   * если у живой клетки есть две или три живых соседних клетки, то клетка продолжает жить, в противном случае клетка
     погибает.

#. Игра завершается в трёх случаях:

   * все клетки погибли;
   * клетки сформировали устойчивую конфигурацию (т.е. на новом шаге не родилось и не погибло ни одной клетки);
   * клетки сформировали периодическую конфигурацию (т.е. клетки в точности повторили свою конфигурацию в один из
     предыдущих моментов).

.. __: https://ru.wikipedia.org/wiki/%D0%96%D0%B8%D0%B7%D0%BD%D1%8C_(%D0%B8%D0%B3%D1%80%D0%B0)

Упражнение №2
+++++++++++++

Напишите программу, реализующую игру «Жизнь». Программа должна считывать начальное состояние поля из текстового файла.

Упражнение №3
+++++++++++++

Проверьте свою программу при помощи известных конфигураций клеток:

* `осцилляторы`__;
* `космические корабли`__;
* `натюрморты`__;
* `планерное ружьё Госпера`__.

.. __: https://ru.wikipedia.org/wiki/%D0%9E%D1%81%D1%86%D0%B8%D0%BB%D0%BB%D1%8F%D1%82%D0%BE%D1%80_(%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F_%D0%BA%D0%BB%D0%B5%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B0)
.. __: https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D1%81%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%BA%D0%BE%D1%80%D0%B0%D0%B1%D0%BB%D1%8C_(%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F_%D0%BA%D0%BB%D0%B5%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B0)
.. __: https://ru.wikipedia.org/wiki/%D0%9D%D0%B0%D1%82%D1%8E%D1%80%D0%BC%D0%BE%D1%80%D1%82_(%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F_%D0%BA%D0%BB%D0%B5%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B0)#.D0.9F.D1.80.D0.BE.D1.81.D1.82.D1.8B.D0.B5_.D0.BF.D1.80.D0.B8.D0.BC.D0.B5.D1.80.D1.8B
.. __: http://www.conwaylife.com/w/index.php?title=Gosper_glider_gun