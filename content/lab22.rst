Работа с файлами, построение графиков
#####################################

:date: 2020-03-17 09:00
:summary: Файлы, time, numpy, matplotlib
:status: draft

.. default-role:: code
.. contents:: Содержание


Базовая работа с файлами
========================
Работа с файлом является работой с *потоком*.
Как программист, вы можете представить, что находитесь на определённой позиции в потоке, а выполняемые вами операции ведутся относительно этой позиции.

Для того, чтобы начать работать с файлом, его необходимо открыть на чтение или запись.
При этом Python предоставляет два режима работы на выбор: текстовый и байтовый.
В основе текстового режима лежат символы - файл представляется, как поток текстовых символов (по умолчанию в кодировке Unicode).
В основе байтового режима обрабатываемая единица потока - байт.

Чтение
------

Пусть в рабочей директории находится файл hello.txt, содержащий всего две строки::
    
    Я первая строка файла!
    А я вторая!

Для открытия файла используется функция `open`.

.. code-block:: pycon
    
    >>> file = open('hello.txt')
    >>> file
    <_io.TextIOWrapper name='hello.txt' mode='r' encoding='UTF-8'>

Её первый аргумент - путь до файла.
Помимо имени можно указать режим работы `mode`, по умолчанию это чтение в текстовом режиме.

Открытый на чтение файл можно

- прочитать полностью `file.read()`
- прочитать `size` символов `file.read(size)`
- прочитать строку `file.readline()`
- прочитать все строки `file.readlines()`

После завершения работы с файлом, его необходимо закрыть `file.close()`.

Вот как выглядит результат работы этих операций:

.. code-block:: pycon

    >>> file.readline()
    'Я первая строка файла!\n'
    >>> file.read(2)
    'А '
    >>> file.read(3)
    'я в'
    >>> file.read(100)
    'торая!\n'
    >>> file.read(1)
    ''
    >>> file.close()

Заметьте, что `file.read(2)` считал символы со втрой строки файла, поскольку первая операция `file.readline()` перенесла поток в новую позицию (на вторую строку).
Также, после `file.read(100)` мы передвинулись в конец потока, поэтому `file.read(1)` возвращает пустую строку.

Файл можно считывать построчно с помощью цикла `for`

.. code-block:: pycon
    
    >>> file = open('hello.txt')
    >>> for line in file:
    ...     print(repr(line))
    ...
    'Я первая строка файла!\n'
    'А я вторая!\n'
    >>> file.close()

Здесь для печати специально использована функция `repr()`, чтобы показать, что в строку входит символ конца строки `\n`.
Очистить строку от него и других символов-пробелов можно с помощью `str.strip()`.

Хорошей практикой является использование конструкции `with`

.. code-block:: pycon
    
    >>> with open('hello.txt') as file:
    ...     for line in file:
    ...         print(line.strip())
    ...
    Я первая строка файла!
    А я вторая!

В конце работы блока `with` файл автоматически закроется.

Запись
------

Для записи в файл необходимо выставить режим на запись

- 'w' - удаление всего содержимого, запись в начало
- 'a' - запись в конец (дописывание)

Типичные операции

- `file.write(str)` - запись строки
- `file.writelines(iterable)` - запись нескольких строк, при этом разделитель строк нужно выставлять вручную

Пример записи трёх строк в файл `out.txt` с последующим выводом содержимого файла

.. code-block:: pycon

    >>> file = open('out.txt', 'w')
    >>> file.write('AAA\n')
    4
    >>> file.writelines(['BBB\n', 'CCC\n'])
    >>> file.close()
    >>> file = open('out.txt')
    >>> content = file.read()
    >>> print(content)
    AAA
    BBB
    CCC

    >>> file.close()

Кроме того, можно производить запись в файл с помощью привычной функции `print`.
У неё есть параметр `file` для перенаправления вывода (по умолчанию это стандартный поток вывода stdout).

Упражнение 1
------------
Скачайте входной файл `in.txt`_.
В каждой его строчке содержится по несколько чисел через пробел.
Вам необходимо создать файл `out.txt`, в каждой строчке которого содержится среднее арифметическое чисел из соответствующей строчки входного файла.

.. _`in.txt`: {static}/extra/lab22/task1/in.txt

Измерение времени работы кода
=============================
Один из простых способов замерить время работы участка кода -- воспользоваться функцией `time.time()`, возвращающей системное время в секундах (см. Epoch time).

Вот пример работы:

.. code-block:: pycon

    >>> import time
    >>> start = time.time()  # начало замера
    >>> print('Hello')
    Hello
    >>> end = time.time()  # конец замера
    >>> print(end-start)
    10.43204402923584

Модуль numpy
============
Библиотека numpy (numerical python) предназначена для эффективной работы с линейной алгеброй.
Многозадачность встроенного типа `list` делает его неудобным и медленным в наукоёмких вычислениях.
Библиотека numpy предоставляет собственный тип данных, более "близкий" к стандартным массивам.
Большинство ресурсоёмких операций выполняется с помощью библиотек языков Си и Фортрана, обёрткой над которыми numpy и является.

Обычно библиотеку numpy импортируют под именем np.

Примеры работы с векторами

.. code-block:: pycon

    >>> import numpy as np
    array([  0,   1,   2,   3, -10])
    >>> a = np.array([0, 1, 2, 3, -10], dtype=np.float)  # dtype является необязательным параметром
    >>> a
    array([  0.,   1.,   2.,   3., -10.])
    >>> b = np.array([1, 4, 5, 6, 8], dtype=np.float)
    >>> a
    array([  0.,   1.,   2.,   3., -10.])
    >>> b
    >>> a + b
    array([ 1.,  5.,  7.,  9., -2.])
    >>> a - b
    array([ -1.,  -3.,  -3.,  -3., -18.])
    >>> a * b
    array([  0.,   4.,  10.,  18., -80.])
    >>> a / b
    array([ 0.  ,  0.25,  0.4 ,  0.5 , -1.25])
    >>> a.dot(b)  # скалярное произведение
    -48.0
    >>> np.sum(a * b)
    -48.0

Некоторые часто используемые конструкторы

.. code-block:: pycon

    >>> np.linspace(0, 10, 5)  # равномерная сетка
    array([ 0. ,  2.5,  5. ,  7.5, 10. ])
    >>> np.linspace(0, 10, 5, dtype=np.int)
    array([ 0,  2,  5,  7, 10])
    >>> np.arange(10)
    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])  # арифметическая прогрессия
    >>> np.arange(1, 10, 3)
    array([1, 4, 7])
    >>> np.random.rand(10)  # вектор из 10 случайных чисел
    array([0.15588698, 0.01149716, 0.51116519, 0.21913986, 0.37452467,
           0.76447507, 0.09531357, 0.62435988, 0.63161721, 0.32714768])

Работа с матрицами

.. code-block:: pycon
    
    >>> a = np.array([1, 2])
    >>> A = np.array([[1, 2], [3, 4]])  # матрица 2x2
    >>> A
    array([[1, 2],
           [3, 4]])
    >>> A.dot(a)  # умножение матрицы на вектор
    array([ 5, 11])
    >>> np.linalg.solve(A, [5,11])  # решение системы уравнений Ax = b, где b = [5, 11]
    array([1., 2.])
    >>> A_inv = np.linalg.inv(A)  # вычисление обратной матрицы A^-1
    >>> A.dot(A_inv)  # проверяем, что A A^-1 = E
    array([[1.0000000e+00, 0.0000000e+00],
           [8.8817842e-16, 1.0000000e+00]])
    >>> np.linalg.det(A)  # вычисление детерминанта матрицы A
    -2.0000000000000004
