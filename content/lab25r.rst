Представление графов.
#####################

:date: 2019-04-02
:summary: Представление графов.
:status: published

.. default-role:: code

.. contents:: Содержание


Введение
========

Данная работа посвящена изучению возможностей библиотеки NetworkX для визуального представления графов.

Библиотека NetworkX
===================

Подключение библиотеки:

.. code-block:: python

	import networkx as nx

NetworkX предназначена для изучения структуры, динамики и функционирования сложных сетей.
Она позволяет создавать и хранить графы в стандартных и нестандартных форматах, генерировать много 
типов случайных и классических графов, анализировать их структуру, строить сетевые модели и создавать
новые алгоритмы.

Библиотека NetworkX относится к *свободному программному обеспечению*, поэтому она может быть распространена и 
изменена согласно лицензии BSD.

Обзор библиотеки NetworkX на русском языке: `https://habrahabr.ru/post/125898/`_

.. _`https://habrahabr.ru/post/125898/`: https://habrahabr.ru/post/125898/

При использовании библиотеки обращайтесь к её актуальной онлайн-документации_. Там же можно найти учебник_ и примеры_!

.. _онлайн-документации: https://networkx.github.io/documentation/latest/
.. _учебник: https://networkx.github.io/documentation/latest/tutorial.html
.. _примеры: https://networkx.github.io/documentation/latest/auto_examples/index.html

Классы графов
-------------
NetworkX содержит четыре класса графов:

* Graph — граф без кратных рёбер (петли допустимы)
* DiGraph — ориентированный граф без кратных рёбер (петли допустимы)
* MultiGraph — граф с кратными рёбрами (в том числе с кратными петлями)
* MultiDiGraph — ориентированный граф с кратными рёбрами (в том числе с кратными петлями)

Внутреннее представление графов реализовано в виде списков смежности (словарь словарей словарей).
Однако во избежании появления несогласованности, все операции с графами должны производится
с использованием API функций библиотеки.

Вершины и рёбра
---------------

Вершиной может быть любой неизменяемый тип с вычислимой функцией `hash()`.
Например, прекрасно подойдут:

* str
* int
* float
* кортеж из строк и чисел
* frozenset (неизменяемое множество)

Каждой вершине можно добавлять и удалять свойства произвольного типа (см. раздел Attributes_).

Рёбра представляют собой связь двух вершин и чаще вершины имеют привязанные к ним данные — свойства рёбер.
Для указания веса ребра, используйте свойство **weight**.

.. _Attributes: http://networkx.readthedocs.io/en/stable/reference/classes.graph.html

Создание графа
--------------

Графы могут быть созданы тремя основными способами:

* явное добавление узлов и рёбер

.. code-block:: python

	G = nx.Graph()                                    # создаём экземпляр графа
	G.add_edge(1, 2)                                  # ребро добавляется сразу со своими вершинами
	G.add_edge(2, 3)                                  # стандартный вес ребра weight=1
	G.add_edge(3, 4, weight = 0.9)                    # можно задать weight сразу при создании ребра
	G.add_node(5)                                     # изолированный узел можно добавить отдельно
	G.add_node(6, x = 1.5, y = -5.0, data = ['any'])  # и сразу задать ему любые свойства

* генераторами графов — алгоритмами порождения стандартных сетевых топологий

.. code-block:: python

	G = nx.complete_graph(10)    # полносвязный граф с 10 вершинами
	G = nx.path_graph(10)        # 10 узлов, расположенных "в линеечку"
	G = nx.cycle_graph(10)       # 10 узлов, связанных кольцом
	G = nx.star_graph(5)         # звезда с 1 узлом в середине и 5 узлами-лучами
	G = nx.balanced_tree(2, 3)   # сбалансированное двоичное дерево высоты 3
	G = nx.empty_graph(10)       # граф с 10 вершинами без рёбер

* импорт данных графа из некоторого формата (обычно из файла)

.. code-block:: python

	d = {0: {1: {'weight': 10}, 2: {'weight': 20}},
	     1: {0: {'weight': 10}, 3: {'weight': 30}},
	     2: {0: {'weight': 20}},
	     3: {1: {'weight': 30}}}
	G = nx.Graph(d)
	dd = nx.to_dict_of_dicts(G) # d == dd

Визуализация графа
------------------

Визуализация графов — нетривиальная задача! Существует много полноценных библиотек,
предназначенных именно для этого:  Cytoscape, Gephi, Graphviz или PGF/TikZ для LaTeX.
Для их использования можно экспортировать граф из NetworkX в формат GraphML.

Однако, есть и самый простой способ визуализации, встроенный в саму библиотеку NetworkX,
при подключении библиотеки `matplotlib.pyplot`.

.. code-block:: python

	nx.draw(G)           # отобразить граф при помощи Matplotlib
	nx.draw_circular(G)  # Использовать расположение circular layout
	nx.draw_random(G)    # Использовать расположение random layout
	nx.draw_spectral(G)  # Использовать расположение spectral layout
	nx.draw_spring(G)    # Использовать расположение spring layout
	nx.draw_shell(G)     # Использовать расположение shell layout
	nx.draw_graphviz(G)  # Использовать graphviz для расположения вершин


Пример визуализации графа №1
++++++++++++++++++++++++++++

.. code-block:: python

	import matplotlib.pyplot as plt
	import networkx as nx

	G=nx.path_graph(8)
	nx.draw(G)
	plt.savefig("simple_path.png") # сохранить как png файл
	plt.show() # вывести на экран

Пример визуализации графа №2
++++++++++++++++++++++++++++

Пример добавления этикеток на вершины и подкрашивания рёбер:

.. code-block:: python

	"""
	Отрисовка графа через matplotlib, с разными цветами.

	"""
	__author__ = """Aric Hagberg (hagberg@lanl.gov)"""

	import matplotlib.pyplot as plt
	import networkx as nx

	G=nx.cubical_graph()
	pos=nx.spring_layout(G) # позиции всех вершин

	# вершины
	nx.draw_networkx_nodes(G, pos,
		               nodelist=[0,1,2,3], # список вершин
		               node_color='r',     # красный цвет
		               node_size=500,      # размер
		           alpha=0.8)              # прозрачность
	nx.draw_networkx_nodes(G, pos,
		               nodelist=[4,5,6,7],
		               node_color='b',
		               node_size=500,
		           alpha=0.8)

	# рёбра
	nx.draw_networkx_edges(G, pos, width=1.0, alpha=0.5) # все рёбра
	nx.draw_networkx_edges(G, pos,
		               edgelist=[(0,1),(1,2),(2,3),(3,0)],
		               width=8, alpha=0.5, edge_color='r')   # красные рёбра
	nx.draw_networkx_edges(G, pos,
		               edgelist=[(4,5),(5,6),(6,7),(7,4)],
		               width=8, alpha=0.5, edge_color='b')   # синие рёбра

	# добавим математические названия вершин
	labels={}
	labels[0]=r'$a$'
	labels[1]=r'$b$'
	labels[2]=r'$c$'
	labels[3]=r'$d$'
	labels[4]=r'$\alpha$'
	labels[5]=r'$\beta$'
	labels[6]=r'$\gamma$'
	labels[7]=r'$\delta$'
	nx.draw_networkx_labels(G, pos, labels, font_size=16)

	plt.axis('off')
	plt.savefig("labels_and_colors.png") # сохранить как png картинку
	plt.show() # вывести на экран


Пример визуализации графа №3
++++++++++++++++++++++++++++

Ещё один пример добавления этикеток на вершины и подкрашивания рёбер:

.. code-block:: python

	"""
	Пример использования Graph как взешенного.
	"""
	__author__ = """Aric Hagberg (hagberg@lanl.gov)"""
	
    import matplotlib.pyplot as plt
	import networkx as nx

	G = nx.Graph()
	
	#   добавляем рёбра и вершины

	G.add_edge('a', 'b', weight=0.6)
	G.add_edge('a', 'c', weight=0.2)
	G.add_edge('c', 'd', weight=0.1)
	G.add_edge('c', 'e', weight=0.7)
	G.add_edge('c', 'f', weight=0.9)
	G.add_edge('a', 'd', weight=0.3)

	elarge = [(u,v) for (u,v,d) in G.edges(data=True) if d['weight'] >0.5]  # "тяжёлые"
	esmall = [(u,v) for (u,v,d) in G.edges(data=True) if d['weight'] <=0.5] # "лёгкие"

	pos = nx.spring_layout(G) # позиции всех вершин

	# вершины
	nx.draw_networkx_nodes(G, pos, node_size=700)

	# рёбра
	nx.draw_networkx_edges(G, pos, edgelist=elarge,
	                width=6)                                   # "тяжёлые"
	nx.draw_networkx_edges(G, pos, edgelist=esmall,
	       width=6, alpha=0.5, edge_color='b', style='dashed') # "лёгкие"

	# метки
	nx.draw_networkx_labels(G,pos,font_size=20,font_family='sans-serif')

	plt.axis('off')
	plt.savefig("weighted_graph.png") # сохранить как png картинку
	plt.show() # вывести на экран


Существует два способа представления графа, в виде списков смежности и в виде матрицы смежности. Оба способа подходят для представления ориентированных и неориентированных графов.


Представление графов матрицами смежности.
=========================================

Этот способ является удобным для представления плотных графов, в которых количество рёбер (|E|) примерно равно количеству вершин в квадрате (|V|^2). 

В данном представлении мы заполняем матрицу размером |V| x |V| следущим образом: 

A[i][j] = 1 (Если существует ребро из i в j)

A[i][j] = 0 (Иначе)

Данный способ подходит для ориентированных и неориентированных графов. Для неориентированных графов матрица A является симметричной
(то есть A[i][j] == A[j][i], т.к. если существует ребро между i и j, то оно является и ребром из i в j, и ребром из j в i). Благодаря этому свойству можно сократить почти в два раза использование памяти, храня элементы только в верхней части матрицы, над главной диагональю)


Понятно что с помощью данного способа представления, можно быстро проверить есть ли ребро между вершинами v и u, просто посмотрев в ячейку A[v][u].


С другой стороны этот способ очень громоздкий, так как требует O (|V|^2) памяти для хранения матрицы.


.. image:: {filename}/images/matrix_graph.png


Списки смежности.
=================


Данный способ представления больше подходит для разреженных графов, то есть графов у которых количество рёбер гораздо меньше чем количество вершин в квадрате (|E| << |V|^2).

В данном представлении используется массив Adj содержащий |V| списков. В каждом списке Adj[v] содержатся все вершины u, так что между v и u есть ребро. Память требуемая для представления равна O (|E| + |V|) что является лучшим показателем чем матрица смежности для разреженных графов.

Главный недостаток этого способа представления в том, что нет быстрого способа проверить существует ли ребро (u, v). 


.. image:: {filename}/images/spisok_graph.png


Алгоритм DFS.
=============


Обход в глубину (поиск в глубину, англ. Depth-First Search, DFS) — один из основных методов обхода графа, часто используемый для проверки связности, поиска цикла и компонент сильной связности и для топологической сортировки. 

Общая идея алгоритма состоит в следующем: для каждой не пройденной вершины необходимо найти все не пройденные смежные вершины и повторить поиск для них.


Пошаговое представление:

1. Выбираем любую вершину из еще не пройденных, обозначим ее как u.

2. Запускаем процедуру dfs(u). 

3. Помечаем вершину u как пройденную. 

4. Для каждой не пройденной смежной с u вершиной (назовем ее v) запускаем dfs(v).

5. Повторяем шаги 1 и 2, пока все вершины не окажутся пройденными.


Зачастую, простой информации "были/не были в вершине" не хватает для конкретных целей.

Поэтому в процессе алгоритма вершинам задают некоторые цвета:

если вершина белая, значит, мы в ней еще не были, вершина не пройдена;

серая — вершина проходится в текущей процедуре dfs;

черная — вершина пройдена, все итерации dfs от нее завершены.

Такие "метки" в основном используются при поиске цикла.

Примеры псевдокода реализации на Python.


.. code-block:: python

	def doDfs(G[n]: Graph): # функция принимает граф G с количеством вершин n и выполняет обход в глубину во всем графе 
            visited = array[n, false]  # создаём массив посещённых вершины длины n, заполненный false изначально
          
            def dfs(u: int):   
      		visited[u] = true
      		for v: (u, v) in G:        
         		if not visited[v]:               
            		   dfs(v)
            for i in range(1, n):             
      		if not visited[i]:                    
         		dfs(i)
	
	#  вариант с цветами
	
	def doDfs(G[n]: Graph): // функция принимает граф G с количеством вершин n и выполняет обход в глубину во всем графе 
            color = array[n, white]
                   
            def dfs(u: int):
                color[u] = gray           
                for v: (u, v) in G:                   
                    if color[v] == white:
                        dfs(v)
                color[u] = black   
                   	   
            for i in range(1, n):
	       if color[i] == white:                
                   dfs(i)



Дерево обхода в глубину.
========================

Рассмотрим подграф предшествования обхода в глубину Gp=(V,Ep), где Ep={(p[u],u):u∈V, p[u]≠NIL}, где в свою очередь p[u] — вершина, от которой был вызван dfs(u)  (для вершин, от которых dfs был вызван нерекурсивно это значение соответственно равно NIL). 

Подграф предшествования поиска в глубину образует лес обхода в глубину, который состоит из нескольких деревьев обхода в глубину. С помощью полученного леса можно классифицировать ребра графа G, который мы обходим в глубину.

1. Ребрами дерева назовем те ребра из G, которые вошли в Gp.

2. Ребра (u,v), соединяющие вершину u с её предком v в дереве обхода в глубину назовем обратными ребрами (для неориентированного графа предок должен быть не родителем, так как иначе ребро будет являться ребром дерева).

3. Ребра (u,v), не являющиеся ребрами дерева и соединяющие вершину u с её потомком v в дереве обхода в глубину назовем прямыми ребрами (в неориентированном графе нет разницы между прямыми и обратными ребрами, поэтому все такие ребра считаются обратными).

4. Все остальные ребра назовем перекрестными ребрами — такие ребра могут соединять вершины одного и того же дерева обхода в глубину, когда ни одна из вершин не является предком другой, или соединять вершины в разных деревьях.


Алгоритм dfs можно модифицировать так, что он будет классифицировать встречающиеся при работе ребра. Ключевая идея состоит в том, что каждое ребро (u,v) можно классифицировать при помощи цвета вершины v при первом его исследовании, а именно:

1. Белый цвет вершины v по определению dfs говорит о том, что это ребро дерева.

2. Серый цвет в силу того, что серые вершины всегда образуют нисходящий путь в каком-либо из деревьев dfs и встреченная вершина v лежит на нем выше вершины u, определяет обратное ребро (для неориентированного графа необходимо проверить условие v≠p[u]).

3. Черный цвет, соответственно, указывает на прямое или перекрестное ребро.


На рисунке: 

1. Синий цвет - обратные рёбра. 

2. Зелёный цвет - прямые рёбра. 

3. Красный цвет - перекрёстные рёбра. 


.. image:: {filename}/images/671px-Colors.png





Топологическая сортировка.
==========================

Дан ориентированный граф с n вершинами и m рёбрами. Требуется перенумеровать его вершины таким образом, чтобы каждое рёбро вело из вершины с меньшим номером в вершину с большим.

Иными словами, требуется найти перестановку вершин (топологический порядок), соответствующую порядку, задаваемому всеми рёбрами графа.

Топологическая сортировка может быть не единственной (например, если граф — пустой; или если есть три такие вершины a, b, c, что из a есть пути в b и в c, но ни из b в c, ни из c в b добраться нельзя).


Топологической сортировки может не существовать вовсе — если граф содержит циклы (поскольку при этом возникает противоречие: есть путь и из одной вершины в другую, и наоборот).


Распространённая задача на топологическую сортировку — следующая. Есть n переменных, значения которых нам неизвестны. Известно лишь про некоторые пары переменных, что одна переменная меньше другой. Требуется проверить, не противоречивы ли эти неравенства, и если нет, выдать переменные в порядке их возрастания (если решений несколько — выдать любое). Легко заметить, что это в точности и есть задача о поиске топологической сортировки в графе из n вершин.


Алгоритм решения. 


Для решения воспользуемся обходом в глубину.


Предположим, что граф ацикличен, т.е. решение существует. Что делает обход в глубину? При запуске из какой-то вершины v он пытается запуститься вдоль всех рёбер, исходящих из v. Вдоль тех рёбер, концы которых уже были посещены ранее, он не проходит, а вдоль всех остальных — проходит и вызывает себя от их концов.


Таким образом, к моменту выхода из вызова {\rm dfs}(v) все вершины, достижимые из v как непосредственно (по одному ребру), так и косвенно (по пути) — все такие вершины уже посещены обходом. Следовательно, если мы будем в момент выхода из {\rm dfs}(v) добавлять нашу вершину в начало некоего списка, то в конце концов в этом списке получится топологическая сортировка.


Эти объяснения можно представить и в несколько ином свете, с помощью понятия "времени выхода" обхода в глубину. Время выхода для каждой вершины v — это момент времени, в который закончил работать вызов {\rm dfs}(v) обхода в глубину от неё (времена выхода можно занумеровать от 1 до n). Легко понять, что при обходе в глубину время выхода из какой-либо вершины v всегда больше, чем время выхода из всех вершин, достижимых из неё (т.к. они были посещены либо до вызова {\rm dfs}(v), либо во время него). Таким образом, искомая топологическая сортировка — это сортировка в порядке убывания времён выхода.




Задача
===================

1. Считать и отобразить граф городов;
2. Представить его разными способами - список смежности, матрица смежности, используя обычные средства Питон.
3. Построить и отобразить остовное дерево методом обхода в глубину (DFS);
4. Написать функцию, осуществляющую топологическую сортировку вершин;

**Дополнительно:**

1. Проверить эйлеровость графа и отобразить эйлеров цикл
2. Найти и отобразить гамильтонов цикл в графе или вывести сообщение, что граф не гамильтонов


Галерея визуализированных графов.
---------------------------------

На официальном сайте NetworkX есть целая `галерея визуализированных графов`_.

.. _`галерея визуализированных графов`: https://networkx.github.io/documentation/stable/auto_examples/index.html



Пример файла с входными данными для задач данной работы
-------------------------------------------------------

.. code-block:: text

	Апельсиновый Мандариновый 100
	Мандариновый Ананасовый 200
	Мандариновый Папайя 300
	Мандариновый Кивиновый 400
	Кивиновый Ананасовый 500
	Яблочный Грушевый 100
	Яблочный Вишнёвый 200
	Вишнёвый Сливовый 300
	Грушевый Сливовый 400
	Вишнёвый Черешневый 500
	Кивиновый Фейхоа 600
	Сливовый Алычовый 600
	Алычовый Терновый 700
	Мандариновый Персиковый 1000
	Персиковый Абрикосовый 300
	Абрикосовый Сливовый 400
	Абрикосовый Алычовый 200
	Земляничный Клубничный 100
	Клубничный Брусничный 200
